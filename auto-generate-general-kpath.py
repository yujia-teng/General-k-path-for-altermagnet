# Script for generating general k-path for band structure calculation
# Author: Yujia Teng, Rutgers University 
# 06/14/2025 - Creation of the script
# 01/12/2026 - Automatically reads the spin-flip operation based on outputs of find_sf_operations.py
import numpy as np
import os
from typing import List, Tuple, Dict, Optional

class KPointsModifier:
    def __init__(self):
        self.kpoints_data = []
        self.header_lines = []
    
    def read_kpoints_file(self, filename: str = "KPOINTS") -> bool:
        """Read KPOINTS file generated by VASPKIT"""
        try:
            with open(filename, 'r') as f:
                lines = f.readlines()
            
            # Parse header (first 4 lines)
            self.header_lines = [line.strip() for line in lines[:4]]
            
            # Parse k-points data
            self.kpoints_data = []
            for line in lines[4:]:
                line = line.strip()
                if line:  # Skip empty lines
                    parts = line.split()
                    if len(parts) >= 4:  # kx, ky, kz, label
                        kx, ky, kz = float(parts[0]), float(parts[1]), float(parts[2])
                        label = parts[3] if len(parts) > 3 else ""
                        self.kpoints_data.append([kx, ky, kz, label])
            
            print(f"Successfully read {len(self.kpoints_data)} k-points from {filename}")
            return True
            
        except FileNotFoundError:
            print(f"Error: File {filename} not found!")
            return False
        except Exception as e:
            print(f"Error reading file: {e}")
            return False

    def load_flip_operations(self, filename: str = "flip_spin_operations.txt") -> List[np.ndarray]:
        """Reads pre-calculated rotation matrices from file"""
        matrices = []
        current_matrix = []
        try:
            with open(filename, 'r') as f:
                lines = f.readlines()
            
            for line in lines:
                line = line.strip()
                if not line or line.startswith("#") or line.startswith("Operation"):
                    continue
                
                parts = line.split()
                if len(parts) == 3:
                    current_matrix.append([float(x) for x in parts])
                
                if len(current_matrix) == 3:
                    matrices.append(np.array(current_matrix))
                    current_matrix = []
            return matrices
        except FileNotFoundError:
            return []
    
    def transform_kpoint(self, kpoint: List[float], transformation_matrix: np.ndarray) -> List[float]:
        """Apply transformation matrix to k-point: R^(-1)^T * k"""
        k = np.array(kpoint[:3])  # Take only x, y, z coordinates
        # Calculate R^(-1)^T
        R_inv_T = np.linalg.inv(transformation_matrix).T
        k_transformed = R_inv_T @ k
        return k_transformed.tolist()
    
    def insert_general_kpoints(self, 
                               general_kpoint: List[float],
                               transformation_matrix: np.ndarray) -> List[List]:
        """
        Insert general k-points into every segment of the high symmetry path.
        """
        if not self.kpoints_data:
            print("Error: No k-points data loaded. Please read KPOINTS file first.")
            return []
        
        # Calculate k' (transformed general k-point)
        k_prime = self.transform_kpoint(general_kpoint, transformation_matrix)
        
        # Find unique points (remove duplicates that create segment boundaries)
        unique_points = []
        i = 0
        while i < len(self.kpoints_data):
            current_point = self.kpoints_data[i]
            unique_points.append(current_point)
            # Skip duplicate points
            while (i + 1 < len(self.kpoints_data) and
                   abs(current_point[0] - self.kpoints_data[i + 1][0]) < 1e-6 and
                   abs(current_point[1] - self.kpoints_data[i + 1][1]) < 1e-6 and
                   abs(current_point[2] - self.kpoints_data[i + 1][2]) < 1e-6):
                i += 1
            i += 1
        
        # --- ORIGINAL PRINTS PRESERVED ---
        print(f"Found {len(unique_points)} unique high-symmetry points")
        for i, point in enumerate(unique_points):
            print(f"  {i}: {point[3]} = ({point[0]:.4f}, {point[1]:.4f}, {point[2]:.4f})")
        # ---------------------------------
        
        # Create new path sequence
        path_sequence = []
        
        # Process each segment between consecutive high-symmetry points
        for i in range(0,len(unique_points) - 2,2):
            current_point = unique_points[i]
            next_point = unique_points[i + 1]
            next_next_point = unique_points[i + 2]

            # Add the original segment: X-Y (no duplication)
            path_sequence.append(current_point.copy())
            path_sequence.append(next_point.copy())
            
            # Add Y-k (Y to general k-point)
            path_sequence.append([general_kpoint[0], general_kpoint[1], general_kpoint[2], "k"])
            
            # Add k'-Y_transformed 
            path_sequence.append([k_prime[0], k_prime[1], k_prime[2], "k_t"])
            if next_point[3].upper() in ['G', 'GAMMA', 'Γ']:
                path_sequence.append(next_point.copy())
            else:            
                # Transform the point
                transformed_coords = self.transform_kpoint(next_point, transformation_matrix)
                transformed_next = [
                    transformed_coords[0], 
                    transformed_coords[1], 
                    transformed_coords[2], 
                    f"{next_point[3]}_t"
                ]
                
                path_sequence.append(transformed_next.copy())
       
            # Add Y_transformed-Z_transformed
            if next_next_point[3].upper() in ['G', 'GAMMA', 'Gamma', 'Γ']:
                path_sequence.append(next_next_point.copy())
            else:
                transformed_coords_2 = self.transform_kpoint(next_next_point, transformation_matrix)
                transformed_next_next = [
                    transformed_coords_2[0],
                    transformed_coords_2[1],
                    transformed_coords_2[2],
                    f"{next_next_point[3]}_t"
                ]
 
                path_sequence.append(transformed_next_next.copy())
             
            # Add Z_transformed-k'
            path_sequence.append([k_prime[0], k_prime[1], k_prime[2], "k_t"])

            # add k-Z
            path_sequence.append([general_kpoint[0], general_kpoint[1], general_kpoint[2], "k"])
            path_sequence.append(next_next_point.copy())

        if len(unique_points) % 2 == 0:
            path_sequence.append(unique_points[-1])

        return path_sequence
    
    def write_kpoints_file(self, new_kpoints: List[List], output_file: str = "KPOINTS_modified",transformation_matrix: Optional[np.ndarray] = None):
        """Write modified KPOINTS file with proper Line-Mode format and discontinuity"""
        try:
            with open(output_file, 'w') as f:
                # Write header 
                if transformation_matrix is not None:
                    flat_matrix = transformation_matrix.flatten()
                    matrix_str = " ".join(f"{x:.8f}" for x in flat_matrix)
                    f.write(f"Obtained from Transformation Matrix: {matrix_str}\n")
                else:
                    f.write(f"{self.header_lines[0]}\n")
                
                f.write("   50\n")    # Number of points between each segment
                f.write(f"{self.header_lines[2]}\n")   # Line-Mode
                f.write(f"{self.header_lines[3]}\n")   # Reciprocal
                
                # Write k-points as segments with special handling for discontinuity
                i = 0
                while i < len(new_kpoints) - 1:
                    start_point = new_kpoints[i]
                    end_point = new_kpoints[i + 1]
                    
                    # Skip any k to k' connections (there should be none)
                    if start_point[3] == "k" and end_point[3] == "k_t":
                        i += 1
                        continue

                    if start_point[3] == "k_t" and end_point[3] == "k":
                        i += 1
                        continue

                    if start_point[3] == end_point[3]:
                        i+=1
                        continue
                    
                    # Write segment: start_point -> end_point
                    f.write(f"   {start_point[0]:.10f}   {start_point[1]:.10f}   {start_point[2]:.10f}     {start_point[3]}\n")
                    f.write(f"   {end_point[0]:.10f}   {end_point[1]:.10f}   {end_point[2]:.10f}     {end_point[3]}\n")
                    
                    # Check if this creates a discontinuity (k is dead end)
                    if end_point[3] == "k":
                        f.write("\n")
                    else:
                        if i < len(new_kpoints) - 2:
                            f.write("\n")
                    i += 1
            
            print(f"Modified KPOINTS file written to: {output_file}")
            return True
            
        except Exception as e:
            print(f"Error writing file: {e}")
            return False

    def interactive_modify(self):
        """Interactive modification of KPOINTS file"""
        print("=== Altermagnetic K-Path Generator ===")
        print("Recommend to use continues high symmetry kpath as input like G-M-K-G rather than L-M|H-K, otherwise there will be duplicated paths.")
        
        # Step 1: Read KPOINTS file
        print("\nStep 1: Reading KPOINTS file...")
        filename = input("Enter KPOINTS file name (default: KPATH.in): ").strip()
        if not filename: filename = "KPATH.in"
        if not self.read_kpoints_file(filename): return
        
        # Step 2: Input general k-point
        print(f"\nStep 2: Enter general k-point coordinates")
        print("Format: kx ky kz (space-separated)")
        while True:
            try:
                k_input = input("Enter k-point: ").strip().split()
                if len(k_input) == 3:
                    general_kpoint = [float(x) for x in k_input]
                    break
                else:
                    print("Please enter exactly 3 coordinates.")
            except ValueError:
                print("Invalid input. Please enter three numbers.")
        
        # Step 3: Input transformation matrix
        print(f"\nStep 3: Selecting Transformation Matrix R")
        flip_ops = self.load_flip_operations()
        
        R = None
        if flip_ops:
            print(f"Found {len(flip_ops)} pre-calculated spin-flip operations:")
            for i, op in enumerate(flip_ops):
                print(f"\n  Option {i+1}:")
                # PRINTING MATRIX IN 3x3 FORMAT
                for row in op:
                    # Integer formatting if integer, else float
                    row_str = " ".join([f"{x: .0f}" if x.is_integer() else f"{x: .2f}" for x in row])
                    print(f"    [ {row_str} ]")
            
            print(f"\nSelect an operation number (1-{len(flip_ops)})")
            choice = input("Press [Enter] for default (1), or type number: ").strip()
            
            if not choice:
                R = flip_ops[0]
                print("Selected default: Option 1")
            else:
                try:
                    idx = int(choice) - 1
                    if 0 <= idx < len(flip_ops):
                        R = flip_ops[idx]
                        print(f"Selected: Option {idx+1}")
                    else:
                        print("Invalid selection, falling back to manual input.")
                except ValueError:
                    print("Invalid input, falling back to manual input.")
        
        if R is None:
            print("No valid operations found or selected. Please enter manually.")
            print("Enter row by row (3 numbers per row, space-separated):")
            transformation_matrix = []
            for i in range(3):
                while True:
                    try:
                        row_input = input(f"Row {i+1}: ").strip().split()
                        if len(row_input) == 3:
                            transformation_matrix.append([float(x) for x in row_input])
                            break
                        print("Please enter exactly 3 numbers.")
                    except ValueError: pass
            R = np.array(transformation_matrix)
        
        # Step 4: Process k-points
        print(f"\nProcessing k-points...")
        # Showing full matrix for confirmation
        print(f"Using Transformation Matrix R:")
        for row in R:
            print(f"  {row}")
            
        # Calculate and show k'
        k_prime = self.transform_kpoint(general_kpoint, R)
        print(f"k' (transformed k): [{k_prime[0]:.4f}, {k_prime[1]:.4f}, {k_prime[2]:.4f}]")
        
        try:
            new_kpoints = self.insert_general_kpoints(general_kpoint, R)
            
            if new_kpoints:
                print(f"\nModified k-points (original: {len(self.kpoints_data)}, new: {len(new_kpoints)}):")
                
                # Step 5: Save modified file
                output_file = input(f"\nEnter output filename (default: KPOINTS_modified): ").strip()
                if not output_file:
                    output_file = "KPOINTS_modified"
                
                self.write_kpoints_file(new_kpoints, output_file,R)
                print(f"\nProcess completed successfully!")
            else:
                print("Error: Failed to process k-points.")
                
        except Exception as e:
            print(f"Error processing k-points: {e}")

if __name__ == "__main__":
    modifier = KPointsModifier()
    modifier.interactive_modify()
